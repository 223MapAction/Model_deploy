name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  cleanup:
    runs-on: self-hosted
    steps:
      - name: Free up disk space
        shell: bash
        run: |
          set -euxo pipefail

          echo "=== Initial disk usage ==="
          sudo df -h

          # Docker cleanup (if Docker is available)
          if command -v docker >/dev/null 2>&1; then
            echo "=== Stopping all running containers ==="
            sudo docker stop $(sudo docker ps -aq) 2>/dev/null || true

            echo "=== Removing all containers ==="
            sudo docker rm -f $(sudo docker ps -aq) 2>/dev/null || true

            echo "=== Pruning Docker system ==="
            sudo docker system prune -af --volumes || true

            echo "=== Removing dangling images ==="
            sudo docker image prune -af || true

            echo "=== Removing unused volumes ==="
            sudo docker volume prune -f || true

            echo "=== Removing unused networks ==="
            sudo docker network prune -f || true
          fi

          # Debian/Ubuntu cleanup
          if command -v apt-get >/dev/null 2>&1; then
            echo "=== Cleaning apt cache ==="
            sudo apt-get clean || true
            sudo apt-get autoclean || true
            sudo apt-get autoremove -y || true
          fi

          # Remove large preinstalled folders (safe if missing)
          echo "=== Removing unnecessary system folders ==="
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc || true

          # Clear temporary files
          echo "=== Clearing temporary files ==="
          sudo rm -rf /tmp/* || true
          sudo rm -rf /var/tmp/* || true

          echo "=== Final disk usage ==="
          sudo df -h

  setup-and-test:
    needs: cleanup
    runs-on: self-hosted
    steps:
      - name: Clean up orphaned files with permission issues
        shell: bash
        run: |
          set -euxo pipefail
          # Remove plot files created by Docker containers
          sudo rm -rf "${{ github.workspace }}/app/plots/*.png" 2>/dev/null || true
          sudo rm -rf "${{ github.workspace }}/local_uploads" 2>/dev/null || true
          sudo rm -f "${{ github.workspace }}/.cv_deploy.env" 2>/dev/null || true
          sudo rm -f "${{ github.workspace }}/gee-credentials.json" 2>/dev/null || true

          # Fix permissions on the workspace
          sudo chown -R admin:admin "${{ github.workspace }}" 2>/dev/null || true

      - name: Checkout Repository
        uses: actions/checkout@v4


      - name: Show system Python (informational)
        shell: bash
        run: |
          set -euxo pipefail
          python3 --version
          python3 -m pip --version || true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Check Docker and Docker Compose
        shell: bash
        run: |
          set -euxo pipefail
          docker --version
          docker compose version

          # Ensure Docker daemon is reachable (use sudo to avoid group timing issues)
          sudo docker info >/dev/null

      - name: Create env file (.cv_deploy.env)
        shell: bash
        run: |
          set -euxo pipefail
          rm -f .cv_deploy.env
          {
            echo "MODEL_PATH=${{ secrets.MODEL_PATH }}"
            echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
            echo "SUPABASE_URL=${{ secrets.SUPABASE_URL }}"
            echo "SUPABASE_KEY=${{ secrets.SUPABASE_ANON_KEY }}"
            echo "USE_SUPABASE_STORAGE=${{ secrets.USE_SUPABASE_STORAGE }}"
            echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}"
            echo "POSTGRES_URL=${{ secrets.POSTGRES_URL }}"
            echo "POSTGRES_USER=${{ secrets.POSTGRES_USER }}"
            echo "REDIS_URL=${{ secrets.REDIS_URL }}"
            echo "COPERNICUS_CLIENT_ID=${{ secrets.COPERNICUS_CLIENT_ID }}"
            echo "COPERNICUS_CLIENT_SECRET=${{ secrets.COPERNICUS_CLIENT_SECRET }}"
            echo "REDIS_HOST=${{ secrets.REDIS_HOST }}"
            echo "REDIS_PORT=${{ secrets.REDIS_PORT }}"
            echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}"
            echo "GEE_SERVICE_ACCOUNT_EMAIL=${{ secrets.GEE_SERVICE_ACCOUNT_EMAIL }}"
            echo "GEE_SERVICE_ACCOUNT_KEY_FILE=/app/gee-credentials.json"
            echo "SERVER_URL=${{ secrets.SERVER_URL }}"
            echo "S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}"
            echo "AWS_REGION=${{ secrets.AWS_REGION }}"
          } >> .cv_deploy.env

          # sanity check (do not print secrets)
          test -s .cv_deploy.env
          echo ".cv_deploy.env created with $(wc -l < .cv_deploy.env) lines."

      - name: Create coverage directory
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p "${{ github.workspace }}/coverage"

      - name: Create GEE credentials file
        shell: bash
        run: |
          set -euxo pipefail
          # Create the credentials file from the secret
          echo '${{ secrets.GEE_SERVICE_ACCOUNT_KEY_CONTENT }}' > gee-credentials.json
          echo "GEE credentials file created"

      - name: Run Tests (Docker Compose)
        shell: bash
        run: |
          set -euxo pipefail
          ls -la .cv_deploy.env

          # Bring up services
          sudo docker compose -f _ci_pipeline.yml up --build -d

          # Run tests and write coverage into mounted folder
          sudo docker compose -f _ci_pipeline.yml run --rm \
            -v "${{ github.workspace }}/coverage:/app/coverage" \
            testing

      - name: Check for coverage file
        shell: bash
        run: |
          set -euxo pipefail
          if [ ! -f "${{ github.workspace }}/coverage/coverage.xml" ]; then
            echo "Coverage file not found at ${{ github.workspace }}/coverage/coverage.xml"
            ls -la "${{ github.workspace }}/coverage" || true
            exit 1
          fi

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        with:
          files: ${{ github.workspace }}/coverage/coverage.xml

      - name: Tear down testing environment
        if: always()
        shell: bash
        run: |
          set -euxo pipefail
          sudo docker compose -f _ci_pipeline.yml down --volumes --remove-orphans || true

      - name: Prune Docker resources (testing)
        if: always()
        shell: bash
        run: |
          set -euxo pipefail
          sudo docker system prune -af || true

  deploy:
    needs: setup-and-test
    runs-on: self-hosted
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Pre-deployment cleanup
        shell: bash
        run: |
          set -euxo pipefail
          echo "=== Pre-deployment disk usage ==="
          sudo df -h

          echo "=== Stopping old deployment containers ==="
          sudo docker compose -f _cd_pipeline.yaml down --remove-orphans || true

          echo "=== Cleaning up test containers ==="
          sudo docker stop $(sudo docker ps -aq) 2>/dev/null || true
          sudo docker rm -f $(sudo docker ps -aq) 2>/dev/null || true

          echo "=== Pruning Docker system before deployment ==="
          sudo docker system prune -af --volumes || true
          sudo docker image prune -af || true

          echo "=== Disk usage after cleanup ==="
          sudo df -h

      - name: Check Docker and Docker Compose
        shell: bash
        run: |
          set -euxo pipefail
          docker --version
          docker compose version
          sudo docker info >/dev/null

      - name: Create env file (.cv_deploy.env)
        shell: bash
        run: |
          set -euxo pipefail
          rm -f .cv_deploy.env
          {
            echo "MODEL_PATH=${{ secrets.MODEL_PATH }}"
            echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
            echo "SUPABASE_URL=${{ secrets.SUPABASE_URL }}"
            echo "SUPABASE_KEY=${{ secrets.SUPABASE_ANON_KEY }}"
            echo "USE_SUPABASE_STORAGE=${{ secrets.USE_SUPABASE_STORAGE }}"
            echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}"
            echo "POSTGRES_URL=${{ secrets.POSTGRES_URL }}"
            echo "POSTGRES_USER=${{ secrets.POSTGRES_USER }}"
            echo "REDIS_URL=${{ secrets.REDIS_URL }}"
            echo "COPERNICUS_CLIENT_ID=${{ secrets.COPERNICUS_CLIENT_ID }}"
            echo "COPERNICUS_CLIENT_SECRET=${{ secrets.COPERNICUS_CLIENT_SECRET }}"
            echo "REDIS_HOST=${{ secrets.REDIS_HOST }}"
            echo "REDIS_PORT=${{ secrets.REDIS_PORT }}"
            echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}"
            echo "GEE_SERVICE_ACCOUNT_EMAIL=${{ secrets.GEE_SERVICE_ACCOUNT_EMAIL }}"
            echo "GEE_SERVICE_ACCOUNT_KEY_FILE=/app/gee-credentials.json"
            echo "SERVER_URL=${{ secrets.SERVER_URL }}"
            echo "S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}"
            echo "AWS_REGION=${{ secrets.AWS_REGION }}"
          } >> .cv_deploy.env

          test -s .cv_deploy.env

      - name: Create GEE credentials file for deployment
        shell: bash
        run: |
          set -euxo pipefail
          # Create the credentials file from the secret
          echo '${{ secrets.GEE_SERVICE_ACCOUNT_KEY_CONTENT }}' > gee-credentials.json
          echo "GEE credentials file created for deployment"

      - name: Build and Deploy (Docker Compose)
        shell: bash
        run: |
          set -euxo pipefail
          sudo docker compose -f _cd_pipeline.yaml build
          sudo docker compose -f _cd_pipeline.yaml down --remove-orphans || true
          sudo docker compose -f _cd_pipeline.yaml up --build -d

      - name: Post-deployment cleanup
        if: always()
        shell: bash
        run: |
          set -euxo pipefail
          sudo docker system prune -af --volumes || true
          sudo docker image prune -af || true
          sudo docker volume prune -f || true
